package com.nedalex.bookmind.data.review

import com.nedalex.bookmind.data.models.Review
import com.nedalex.bookmind.domain.review.ReviewRepository
import io.github.jan.supabase.SupabaseClient
import io.github.jan.supabase.postgrest.from
import io.github.jan.supabase.postgrest.query.Order
import kotlinx.datetime.Clock
import kotlin.time.ExperimentalTime

class ReviewRepositoryImpl(
    private val supabaseClient: SupabaseClient
) : ReviewRepository {

    companion object {
        private const val TABLE_REVIEWS = "reviews"
    }

    override suspend fun getReviewsForBook(bookId: String): Result<List<Review>> = runCatching {
        supabaseClient
            .from(TABLE_REVIEWS)
            .select {
                filter {
                    eq("book_id", bookId)
                }
                order("created_at", order = Order.ASCENDING)
            }
            .decodeList<Review>()
    }

    override suspend fun getUserReviewForBook(
        userId: String,
        bookId: String
    ): Result<Review?> = runCatching {
        val reviews = supabaseClient
            .from(TABLE_REVIEWS)
            .select {
                filter {
                    eq("user_id", userId)
                    eq("book_id", bookId)
                }
            }
            .decodeList<Review>()

        reviews.firstOrNull()
    }

    override suspend fun getReviewsByUser(userId: String): Result<List<Review>> = runCatching {
        supabaseClient
            .from(TABLE_REVIEWS)
            .select {
                filter {
                    eq("user_id", userId)
                }
                order("created_at", order = Order.DESCENDING)
            }
            .decodeList<Review>()
    }

    @OptIn(ExperimentalTime::class)
    override suspend fun addReview(
        bookId: String,
        userId: String,
        rating: Int,
        reviewText: String?
    ): Result<Review> = runCatching {
        val review = Review(
            id = "", // Will be auto-generated by Supabase
            bookId = bookId,
            userId = userId,
            userName = null, // Will be populated by database trigger or join
            rating = rating,
            reviewText = reviewText,
            createdAt = kotlin.time.Clock.System.now().toString(),
            updatedAt = null
        )

        supabaseClient
            .from(TABLE_REVIEWS)
            .insert(review)
            .decodeSingle<Review>()
    }

    @OptIn(ExperimentalTime::class)
    override suspend fun updateReview(
        reviewId: String,
        rating: Int,
        reviewText: String?
    ): Result<Review> = runCatching {
        supabaseClient
            .from(TABLE_REVIEWS)
            .update(
                mapOf(
                    "rating" to rating,
                    "review_text" to reviewText,
                    "updated_at" to kotlin.time.Clock.System.now().toString()
                )
            ) {
                filter {
                    eq("id", reviewId)
                }
            }
            .decodeSingle<Review>()
    }

    override suspend fun deleteReview(reviewId: String): Result<Unit> = runCatching {
        supabaseClient
            .from(TABLE_REVIEWS)
            .delete {
                filter {
                    eq("id", reviewId)
                }
            }
    }
}